use crate::condition::Condition;
use crate::addrreg::AddrReg;
use crate::dataloc::DataLoc;

#[derive(Debug, Clone)]
pub enum Instruction {
    LD(DataLoc, DataLoc),
    LD5,
    LD6,
    LDD(DataLoc, DataLoc),
    LDI(DataLoc, DataLoc),
    LDH1(u8),
    LDH2(u8),
    LD16(AddrReg, u16),
    LDSPHL,
    LDHL(i8),
    LDnn(u16),
    PUSH(AddrReg),
    POP(AddrReg),
    ADD(DataLoc),
    ADC(DataLoc),
    SUB(DataLoc),
    SBC(DataLoc),
    AND(DataLoc),
    OR(DataLoc),
    XOR(DataLoc),
    CP(DataLoc),
    INC(DataLoc),
    DEC(DataLoc),
    ADD16(AddrReg),
    ADD16n(i8),
    INC16(AddrReg),
    DEC16(AddrReg),
    SWAP(DataLoc),
    DAA,
    CPL,
    CCF,
    SCF,
    NOP,
    HALT,
    STOP,
    DI,
    EI,
    RLCA,
    RLA,
    RRCA,
    RRA,
    RLC(DataLoc),
    RL(DataLoc),
    RRC(DataLoc),
    RR(DataLoc),
    SLA(DataLoc),
    SRA(DataLoc),
    SRL(DataLoc),
    BIT(u8, DataLoc),
    SET(u8, DataLoc),
    RES(u8, DataLoc),
    JP1(u16),
    JP2(Condition, u16),
    JP3,
    JR4(i8),
    JR5(Condition, i8),
    JPc(Condition, u16),
    CALL(u16),
    CALLc(Condition, u16),
    RST(u8),
    RET,
    RETc(Condition),
    RETI,
}

impl Instruction {
    pub fn clock_cycles(&self) -> u8 {
        match self {
            // DONE UNTIL HERE
            Instruction::LD(_, _) => 4,
            Instruction::LD5 => 4,
            Instruction::LD6 => 4,
            Instruction::LDD(_, _) => 4,
            Instruction::LDI(_, _) => 4,
            Instruction::LDH1(_) => 4,
            Instruction::LDH2(_) => 4,
            Instruction::LD16(_, _) => 4,
            Instruction::LDSPHL => 4,
            Instruction::LDHL(_) => 4,
            Instruction::LDnn(_) => 4,
            Instruction::PUSH(_) => 4,
            Instruction::POP(_) => 4,
            Instruction::ADD(_) => 4,
            Instruction::ADC(_) => 4,
            Instruction::SUB(_) => 4,
            Instruction::SBC(_) => 4,
            Instruction::AND(_) => 4,
            Instruction::OR(_) => 4,
            Instruction::XOR(_) => 4,
            Instruction::CP(_) => 4,
            Instruction::INC(_) => 4,
            Instruction::DEC(_) => 4,
            Instruction::ADD16(_) => 4,
            Instruction::ADD16n(_) => 4,
            Instruction::INC16(_) => 4,
            Instruction::DEC16(_) => 4,
            Instruction::SWAP(_) => 4,
            Instruction::DAA => 4,
            Instruction::CPL => 4,
            Instruction::CCF => 4,
            Instruction::SCF => 4,
            Instruction::NOP => 4,
            Instruction::HALT => 4,
            Instruction::STOP => 4,
            Instruction::DI => 4,
            Instruction::EI => 4,
            Instruction::RLCA => 4,
            Instruction::RLA => 4,
            Instruction::RRCA => 4,
            Instruction::RRA => 4,
            Instruction::RLC(_) => 4,
            Instruction::RL(_) => 4,
            Instruction::RRC(_) => 4,
            Instruction::RR(_) => 4,
            Instruction::SLA(_) => 4,
            Instruction::SRA(_) => 4,
            Instruction::SRL(_) => 4,
            Instruction::BIT(_, _) => 4,
            Instruction::SET(_, _) => 4,
            Instruction::RES(_, _) => 4,
            Instruction::JP1(_) => 4,
            Instruction::JP2(_, _) => 4,
            Instruction::JP3 => 4,
            Instruction::JR4(_) => 4,
            Instruction::JR5(_, _) => 4,
            Instruction::JPc(_, _) => 4,
            Instruction::CALL(_) => 4,
            Instruction::CALLc(_, _) => 4,
            Instruction::RST(_) => 4,
            Instruction::RET => 4,
            Instruction::RETc(_) => 4,
            Instruction::RETI => 4,
        }
    }

    pub fn machine_cycles(&self) -> u8 {
        self.clock_cycles() / 4
    }
}